В пайплайне решателя используются три класса residuals:
- (1) геометрические ограничения из исходной программы (длины, параллельность, углы, принадлежности и т.д.)
- (2) «охранные» guard-остатки против вырождений (минимальные расстояния, нижние пороги рёбер, минимальная площадь, непараллельность ног трапеции, «поворотная» выпуклость)
- (3) калибровочные gauges (якорь, ориентация, единичный масштаб). Все они суммируются в общий вектор и минимизируются `scipy.optimize.least_squares`.

---

## Полный список residuals с пояснениями

Ниже — **что именно добавляется в модель**, **какая математика** стоит за каждым residual, **его ключ (key)/вид (kind)** и **зачем он нужен**. Все векторы и скаляры вычисляются на массиве параметров `x` (координаты точек), вспомогательные функции:

* `u×v` — псевдоскалярное 2D-перекрестное произведение (`_cross_2d`),
* `‖·‖²` — квадрат нормы,
* `hinge(t)=½(t+√(t²+ε²))` — гладкая версия `max(0,t)` (`_smooth_hinge`),
* нормализации и защитные ε для стабильности деления.

### 1) Геометрические ограничения из исходных операторов

* **Фиксированная длина отрезка**

  * **key**: `segment_length(A-B=L)`; **kind**: `segment_length`; **size**: 1
  * **формула**: `‖B−A‖² − L² = 0`
  * **зачем**: зафиксировать метрику конкретного сегмента. Поддерживает `length|distance|value`.

* **Равенство длин отрезков**

  * **key**: `equal_segments(A-B,C-D,...)`; **kind**: `equal_segments`; **size**: *кол-во сравниваемых − 1*
  * **формула**: для каждого `S`: `‖S‖² − ‖ref‖² = 0`
  * **зачем**: сделать несколько отрезков равными без абсолютной шкалы.

* **Параллельность рёбер**

  * **key**: `parallel_edges(A-B,C-D,...)`; **kind**: `parallel_edges`; **size**: *кол-во − 1*
  * **формула**: `cross(B−A, D−C) = 0` для каждого к ref
  * **зачем**: обеспечить параллельность направлений.

* **Прямой угол в вершине**

  * **key**: `right_angle(V)`; **kind**: `right_angle`; **size**: 1
  * **формула**: `(u·v) = 0`, где `u` и `v` — два луча в точке `V`
  * **зачем**: обеспечить ортогональность.

* **Заданный угол в градусах**

  * **key**: `angle(V)=θ`; **kind**: `angle`; **size**: 1
  * **формула**: `cos(u,v) − cos(θ) = 0` с безопасной нормировкой
  * **зачем**: задать угол между двумя лучами.

* **Точка на прямой/отрезке/луче**

  * **key**: `point_on_line(P,A-B)` / `point_on_segment(P,A-B)` / `point_on_ray(P,A-B)`; **kind**: `point_on_*`; **size**: 1
  * **формула** (соосность): `cross(B−A, P−A) = 0`
  * **доп. границы для отрезка/луча**:

    * **key**: `point_on_segment_bounds(...)`; **kind**: `point_on_segment_bounds`; **size**: 2

      * **формулы**: `hinge(−proj)`, `hinge(proj − ‖B−A‖²)`, где `proj=(P−A)·(B−A)`
    * **key**: `point_on_ray_bounds(...)`; **kind**: `point_on_ray_bounds`; **size**: 1

      * **формула**: `hinge(−proj)`
  * **зачем**: удержать точку на носителе и внутри допустимого диапазона.

* **Точка на окружности**
  Два варианта: радиус числом или через опорную точку радиуса.

  * **key**: `point_on_circle(P,C)`; **kind**: `point_on_circle`; **size**: 1
  * **формулы**:

    * с числом `r`: `‖P−C‖² − r² = 0`
    * с `radius_point R`: `‖P−C‖² − ‖R−C‖² = 0`
  * **зачем**: задать окружность явно или по ссылке.

* **Точка на биссектрисе угла**

  * **key**: `point_on_angle_bisector(P,V;V-A,V-B)` (добавляется `;external` для внешней биссектрисы); **kind**: `point_on_angle_bisector`; **size**: 1
  * **формула**: `normalized_cross(P−V, u ± v) = 0`, где `u = (A−V)/‖A−V‖`, `v = (B−V)/‖B−V‖`; сумма соответствует внутренней, разность — внешней биссектрисе.
  * **зачем**: позиционировать на нужной биссектрисе без двусмысленностей и с явным выбором внешней/внутренней.

* **Точка на перпендикуляре из заданной точки к ребру**

  * **key**: `point_on_perpendicular(P,At;C-D)`; **kind**: `point_on_perpendicular`; **size**: 1
  * **формула**: `( (D−C) · (P−At) ) = 0`
  * **зачем**: задать направление перпендикуляра через ортогональность.

* **Точка на медиане треугольника**

  * **key**: `point_on_median(P,V;A-B)`; **kind**: `point_on_median`; **size**: 1
  * **формула**: `cross(P−V, mid(A,B) − V) = 0`
  * **зачем**: провести медиану из вершины к середине противоположной стороны.

* **Коллинеарность точек**

  * **key**: `collinear(A,B,C,...)`; **kind**: `collinear`; **size**: *кол-во точек − 2*
  * **формула**: для каждой последующей `T`: `cross(B−A, T−A) = 0`
  * **зачем**: выровнять набор точек на одной прямой.

* **Середина отрезка (midpoint)**

  * **key**: `midpoint(M,A-B)`; **kind**: `midpoint`; **size**: 2
  * **формула (векторная)**: `2M − (A+B) = 0` (две координаты)
  * **зачем**: зафиксировать точку как середину.

* **Основание перпендикуляра на ребре (foot)**

  * **key**: `foot(V->H on A-B)`; **kind**: `foot`; **size**: 2
  * **формулы**:

    * принадлежность: `cross(B−A, H−A) = 0`
    * перпендикулярность: `(V−H)·(B−A) = 0`
  * **зачем**: спроецировать из вершины на сторону.

* **Явное расстояние между двумя точками**

  * **key**: `distance(A-B)=d`; **kind**: `distance`; **size**: 1
  * **формула**: `‖B−A‖² − d² = 0`
  * **зачем**: альтернативный ввод числовых расстояний.

* **Семейство четырёхугольников (convexity guard)**
  Для `quadrilateral|parallelogram|trapezoid|rectangle|square|rhombus`:

  * **key**: `<kind>(A-B-C-D):convexity`; **kind**: `convexity`; **size**: 8
  * **формула**:

    * для каждой вершины i: `hinge(τ − |turn_i|)` (4 шт.), где `turn_i = sin угла` (нормированная площадь треугольника)
    * для согласованности знаков поворотов: `hinge(σ − turn_i·turn_{i+1})` (ещё 4)
  * **зачем**: мягко подталкивает к невырожденной «выпуклой» циркуляции поворотов.

### 2) Глобальные «охранные» residuals против вырождений

Добавляются **поверх** пользовательских ограничений на этапе `translate`.

* **Минимальная сепарация для всех пар точек**

  * **key**: `min_separation(A-B)`; **kind**: `min_separation`; **size**: 1
  * **формула**: `hinge( (d_min)² − ‖B−A‖² )`
  * **параметр**: `d_min = 0.1 * scene_scale`
  * **зачем**: категорически мешает слипанию любых двух точек.

* **Нижний порог длины для рёбер многоугольников**

  * **key**: `edge_floor(A-B)`; **kind**: `edge_floor`; **size**: 1
  * **формула**: `hinge( (L_min)² − ‖B−A‖² )`
  * **параметр**: `L_min = 0.1 * scene_scale`
  * **зачем**: не даёт сторонам многоугольника схлопываться.

* **Лёгкий нижний порог для «несущих» (carrier) рёбер вне многоугольников**

  * **key**: `edge_floor(A-B)`; **kind**: `edge_floor`; **size**: 1
  * **формула**: та же, но
  * **параметр**: `L_min = 0.02 * scene_scale`
  * **зачем**: слегка страхует вспомогательные отрезки, не мешая гибкости.

* **Минимальная площадь для каждого многоугольника**

  * **key**: `area_floor(A-B-C-...)`; **kind**: `area_floor`; **size**: 1
  * **формула**: `hinge( A_min − |area| )`, где `area` — полуплощадь по шнуру,
  * **параметр**: `A_min = (0.02 * scene_scale)²`
  * **зачем**: предотвращает почти нулевую площадь (сжатие в линию).

* **Угловой «поворотный» маргин для многоугольника**

  * **key**: `turn_margin(A-B-C-...)`; **kind**: `turn_margin`; **size**: *число вершин*
  * **формула**: для каждого узла `i`: `hinge( τ − |turn_i| )`, `τ≈sin(1°)`
  * **зачем**: удерживает локальные углы от деградации (почти коллинеарности).

* **Непараллельность ног трапеции (если базы известны)**

  * **key**: `nonparallel(A-B,C-D)`; **kind**: `nonparallel`; **size**: 1
  * **формула**: `hinge( τ_np − |sin∠(legs)| )`, `τ_np = sin(0.0005°)` — очень мягкая
  * **зачем**: запрещает строго параллельные ноги без наказания за почти-параллельные.

> **Примечание про масштаб**: `scene_scale` собирается из всех числовых длин/радиусов в задаче; если их нет — используются gauge-масштабы (см. ниже).

### 3) Калибровочные (gauge) residuals

Нужны, чтобы устранить неизнаблюдаемые степени свободы: сдвиг, вращение и масштаб.

* **Якорь координат (сдвиг = 0)**

  * **key**: `gauge:anchor(P0)`; **kind**: `gauge`; **size**: 2
  * **формула**: `(x(P0), y(P0)) → (0,0)`
  * **зачем**: фиксирует начало координат.

* **Ориентация (знак поворота/наклон осей)**

  * **key**: `gauge:orientation(A-B)`; **kind**: `gauge`; **size**: 1
  * **формула**: `y(B) − y(A) = 0` ⇒ ориентирует ребро горизонтально
  * **выбор ребра**: если описан трапецоид с указанием базы — берётся база; иначе — первое встретившееся ребро.
  * **зачем**: убивает глобальное вращение.

* **Единичный пролет по оси X (масштаб), если нет числовых длин**

  * **key**: `gauge:unit_span(A-B)`; **kind**: `gauge`; **size**: 1
  * **формула**: `x(B) − x(A) − 1 = 0`
  * **условие**: добавляется **только если** в сцене не было ни одной числовой длины/радиуса
  * **зачем**: фиксирует масштаб при полностью безразмерной постановке.

---

## Как всё это складывается в решении

* Конструктор модели прогоняет программу, **собирает** все спецификации (`ResidualSpec`) и глобальные guard’ы, регистрирует «несущие» рёбра и многоугольники, и **вычисляет масштаб сцены** из численных значений.
* Затем `solve()` формирует **единый вектор residuals** (конкатенация всех блоков) и минимизирует его методами `least_squares` (`method="trf"`, `loss="linear"` по умолчанию), с несколькими перезапусками и детерминированным/случайным сидом.
* Метрика качества решения — **максимальный модуль остатка**; в отчёте присутствует **breakdown** по каждому ключу/виду residual.

---

## Ключевые константы, влияющие на поведение residuals

* ` _MIN_SEP_SCALE = 1e-1` — жёсткая минимальная сепарация точек от масштаба.
* `_EDGE_FLOOR_SCALE = 1e-1` — нижний порог длин рёбер многоугольников.
* `_CARRIER_EDGE_FLOOR = 2e-2` — мягкий порог для «несущих» рёбер вне полигона.
* `_AREA_MIN_SCALE = 2e-2` — минимальная площадь полигона (в квадрате масштаба).
* `_TURN_MARGIN = sin(1°)` — запас по «повороту» в вершинах.
* `_TAU_NONPAR = sin(5e-4°)` — микрозазор против параллельности ног трапеции.
* Гладкая «петля» `_smooth_hinge` с `ε≈1e-9` обеспечивает дифференцируемость.

---

## Итоговая карта видов residuals

* **Геометрия**: `segment_length`, `equal_segments`, `parallel_edges`, `right_angle`, `angle`, `point_on_line/segment/ray(+bounds)`, `point_on_circle`, `point_on_angle_bisector`, `point_on_perpendicular`, `point_on_median`, `collinear`, `midpoint`, `foot`, `distance`, `convexity` (для семейства четырёхугольников).
* **Глобальные guard’ы**: `min_separation`, `edge_floor` (полигоны и carrier), `area_floor`, `turn_margin`, `nonparallel` (ноги трапеции).
* **Gauge’и**: `gauge:anchor`, `gauge:orientation`, `gauge:unit_span` (условный).
